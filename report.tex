% Report cours C++
% Artem Oboturov, Ludwig Brummer
% le 12 Janvrier 2013
\documentclass[a4paper]{article}
\usepackage[francais]{babel}
%\usepackage[framed]{mcode}
\usepackage[final,pdftex]{graphicx}
\usepackage{todonotes}
\usepackage{listings}

\newtheorem{algo}{Algorithme}

\begin{document}
\lstset{language=C++,tabsize=2, numbers=left}
\listoftodos

\title{Le projet Mosaic}
\author{
  Artem Oboturov\thanks{oboturov@telecom-paristech.fr}
  \\Ludwig Brummer\thanks{ludwig.brummer@mytum.de}
}
\date{le 21 Janvrier 2013}
\maketitle
\section{Description du projet}


\section{Organisation de travail sur projet}
Un probl\`eme, que on a rencontr\'e en d\'ebut de travail sur le projet, c'\'etait la nature distributive de l'\'equipe.
Pour travailler effectivement \`a distance, on a trouv\'e un site specialis\'e en gestion de projets en ligne.
Le projet a \'et\'e organis\'e atour de site Github - le portal de travail collaborative sur les logiciels.
Ce site garde le code source et donne acc\'es vers ce code par syst\`eme de contr\^ole de versions Git. Par ailleurs il montre tous les contributions de chaque collaborateur ligne par ligne dans le code et donne des diagrammes d'activit\'e et productivi\'e des collaborateurs.\\
Il y a un composant de gestion de projet permettant \`a cr\'eer des billets sur le taches de d\'eveloppement.
De plus il est possible de faire des branches dans le projet pour travailler parallèlement sur des m\^emes fiches et les r\'eunifier apr\`es.\\
On a cr\'e\'e un projet priv\'e (non accessible par personnes non autoris\'ees).
\section{Instruction d'emploi}
Dans le chapitre suivant le mode d'emploi du programme est pr\'esent\'e.
\subsection{La biblioth\`eque des carreaux}
D'abord on a besoin d'une certaine quantit\'e des images de lesquelles la programme construira la mosa\"{i}que.
 Pour un bon r\'esultat on a besoin de cinquante images au moins dans le dossier "imageLibrary" dans le dossier du programme.

Tous ces images doivent avoir la m\^eme taille.
Pour y arriver, on peut utiliser le programme "library\_generator.exe" ou d'abord le commande "make library\_generator" s'il ne se trouve pas d\'ej\`a dans le dossier du programme.
 Le programme copiera tous les images dans le dossier "inputImages" dans le dans dossier "libraryImages" et r\'eduira les tailles des images \`a un taille quadratique qui peut \^etre sp\'ecifi\'e dans la ligne de commande.
 Agrandir des images n'est pas possible avec ce programme.
 
 Le programme peut \^etre \'execut\'e avec deux different options dans la ligne de commande.
 
 D'abord on peut sp\'ecefier la taille des images souhait\'e apr\`es la commande "{-}{-}size" avec un nombre entier positif.
 La taille d\'efaute est 100 pixels.
Alors un \'execution exemplaire serait ".\textbackslash library\_generator {-}{-}size 50".

Et puis il y a l'option "{-}{-}help" qui r\'ep\'etera toute l'information ces instructions.

Il faut faire attention: le programme ne va pas couper des parties des images mais seulement r\'eduire la taille alors les proportions peuvent \^etre chang\'e.
Ce fa\c{c}on de r\'eduire a quelque avantages et disavantages mais pourrait facilement \^etre changer par couper la partie d'image qui est "trop" et r\'eduire apr\`es.

\subsection{Le programme principal}
Maintenant que nous avons une biblioth\`eque assez grand et de la m\^eme taille dans le dossier "libraryImages", on doit effacer tous les images dans le dossier "inputImages" sauf ceux qui sont destin\'e \`a devenir des mosa\"iques.
Puis on peut ex\'ecuter la programme ".\textbackslash m2mo\_brummer\_oboturov\_project.exe".
L\`a aussi il y a des options qui peuvent \^etre ajout\'e dans la ligne de commande.

"{-}{-}help" ou "-h" ouvrira plus ou moins les m\^emes informations que ce paragraphe mais n'ex\'ecutera pas le mosaic maker.

Avec les options "{-}{-}mse" ou "-a", "{-}{-}meancolor" ou "-b" et "{-}{-}mcmse" ou "-c" on peut choisir entre des mesures de divergence.

Avec l'option "{-}{-}tilesize" et un nombre positif entier on peut chosir la taille des carreaux, c'est-\`a-dire les sections qui sont remplacer par des autres images.

Les options peuvent \^etre \'ecrit dans n'importe quel ordre.
Les d\'efautes sont la mesure de Monte Carlo et un taille de 20 pixels.

Le programme annoncera quand un mosa\"ique est fini.
 Ils sont sauvegard\'es dans le dossier "outputImages". 
\section{Structure de code}
\subsection{La implementation des images}

\subsection{L'ordre et l'acc\`es aux images}

\subsection{La d\'ecoupage des images}

\subsection{La comparaison entre deux images et les blocs}

\subsection{L'ex\'ecution avec des option dans la linge de commande}

\subsection{Le library\_generator}

\section{Algorithmique}

\subsection{Le scaling algorithme}

Le scaling algorithme est utilis\'e pour changer tout les images destin\'e pour la bibliothèque à une taille uniforme.
Ici on doit se rendre compte qu'il est seulement capable à diminuer la taille des images car c'est l'usage r\'ealiste pendant un construction d'un mosa\"{i}que.  
Pendant un agrandissement il y aura des fautes.

Il se trouve dans la fonction Image\& Image::scale\_to(Image\& downscaled) dans les fichiers image.h et image.cpp.
Alors il fait partie de la classe Image comme on peut voir dans le code.
Elle re\c{c}oit comme param\'etre la reference d'une image "downscaled" qui a la taille \`a laquelle on veut changer l'image originale.

L'algorithme est le Listing \ref{algo-scaling}
%\begin{figure}[h]\label{algo-scaling}
%\caption{L'algorithme de sous\'echantillonnage lin\'eaire}
\lstset{caption={L'algorithme de sous\'echantillonnage lin\'eaire},label={algo-scaling}}
\begin{lstlisting}
img_size_t	desiredw = downscaled.get_width(),
			desiredh = downscaled.get_height();

float paceh = height/desiredh;
float pacew = width/desiredw;
float norm = paceh*pacew;
int y = 0;// pixel positions for big image
int x = 0;
for(int i = 0; i < desiredw; i++)
{
	x=i*pacew;
	for(int j = 0; j < desiredh; j++)
	{
	y = j*paceh;
		for(img_color_layer_t layer = 0; layer < LAYER_CNT; layer++)
		{
			float color = 0;
			for (int cnth = 0; cnth < int(paceh); cnth++)
			{
				for (int cntw = 0; cntw < int(pacew); cntw++)
					color += (float)(*this)(x + cntw, y + cnth, layer);
			}
			downscaled(i, j, layer) = color/norm;
		}
	}	
}
\end{lstlisting}
%\end{figure}

 D'abord

\subsection{Les mesures de divergence}
\subsubsection{La mesure de erreur des moindres carr\'es}

$X,Y,C$ correspondent aux tailles en dimension horizontal, vertical et couleur. $C$ est toujours 3. 
\begin{equation}
err=\frac{1}{X\cdot Y\cdot C}\sum_{x,y,c}\left(\frac{block(x,y,c)-tile_{image}(x,y,c)}{255}\right)^2
\end{equation}
\subsubsection{La mesure de couleurs moyens}

\subsubsection{La mesure de Monte Carlo}
Soient $(Z_{x,y,c})$ une suite des variables al\'eatoires i.i.d. de la loi Bernoulli avec $p~=~0,25$.
\begin{equation}
err=\frac{1}{\sum_{x,y,c}Z_{x,y,c}}\sum_{x,y,c}\left(\frac{block(x,y,c)-tile_{image}(x,y,c)}{255}\right)^2\cdot Z_{x,y,c}
\end{equation}



\section{Resultats}
Comparaison des mesures de divergence: vitesse, qualit\'e (subjectif)
Exp\'erimente sur le m\^eme ordinateur avec 200 (nombre aléatoire mais fixe) images entre les mesures.
 Prends le temps. Apr\`es montre les r\'esultats et discute un peu la qualit\'e. 

%\begin{figure}[t]
%	\begin{center}
%		\lstinputlisting{trace_frontieres.m}
%	\end{center}
%	\caption{Fichier {\em trace\_frontieres.m}}
%	\label{fig:OptimizationProblemWithAuthorizedSalesListing1}
%\end{figure}

\end{document}
